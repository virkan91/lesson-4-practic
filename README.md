# Table of Contents
### 1.**SCOPE**   
### 2.**HOISTING**
### 3.**Recursion**
### 4.**Closure
_________________

![Tux, the Linux mascot](/img/js.jpg)

## Введение в JavaScript scope
Введение в JavaScript scope (область видимости функции, область видимости блока).

* Область видимости или Scope
* Глобальная область видимости или Global Scope.
*  Область видимости или Scope
* Локальная область видимости или Local Scope.
* Область видимости функции.
* Область видимости блока.
* Лексическая область видимости
* Динамическая область видимости.
_________________

![Tux, the Linux mascot](/img/js-hostint.jpg)

## Поднятие или hoisting в JavaScript
Что такое "поднятие" и как оно работает в JavaScript.

1. Поднятие (hoisting).
2. Поднятие функций.
3. Поднятие const, let и var.
    - Ключевое слово var
    - Ключевое слово const/let

## Поднятие (hoisting)

Поднятие предполагает, что объявления переменных **var** и функций **function** физически перемещаются в начало кода, но, на самом деле это не так.

По сути, когда Javascript компилирует весь код, все объявления переменных, использующие **var**, поднимаются/hoisted в верхнюю часть их функциональной/локальной области видимости (если объявляется внутри функции) или в глобальную область видимости (если объявляется вне функции) независимо от того, где была сделана фактическая декларация.

Объявления переменных и функций помещаются в память на этапе компиляции, но они остаются именно там, где мы ввели их в свой код.

Итак, под капотом происходит следующее: на этапе создания, движок JavaScript просматривает код и, как только он видит ключевое слово **var** или ключевое слово **function**, он выделяет некоторую память для них.

## Поднятие const, let и var
**var** - это традиционный способ объявления переменных в JavaScript.

ES6 (ECMAScript 6) представил два новых способа объявления переменных: **const** и **let**, и, как правило, они рекомендуются во избежание неожиданных осложнений при подъеме.

### Ключевое слово var

*  **var** имеет область действия функции;
* объявления var поднимаются, но не инициализируются.

![Tux, the Linux mascot](/img/var.png)

Приведенный выше код, из-за поднятия эквивалентен приведенному коду ниже.

![Tux, the Linux mascot](/img/var-2.png)

## Ключевые слова const / let
* **const** и let имеют область видимости блока.

На самом деле объявления **var**, **let**, **const**, **function** и **class** поднимаются; но, мы должны помнить, что концепция поднятия не является буквальным процессом (т. е. сами объявления не перемещаются в начало файла - это просто процесс компилятора JavaScript, который сначала читает их, чтобы освободить для них место в памяти).

Разница между объявлениями **var / function** и объявлениями **let / const / class** заключается в инициализации. Первые инициализируются с неопределенным значением undefined. Однако, вторые, лексически объявленные переменные, остаются не инициализированными. Это означает, что ReferenceError выбрасывается при попытке доступа к ним. Они будут инициализированы только после того, как операторы **let / const / class** будут определены. Всё что до, называется временной мертвой зоной.

Временная мертвая зона - это не синтаксическое местоположение, а время между созданием переменной (области) и инициализацией. Ссылка на переменную в коде над объявлением не является ошибкой, если этот код не выполняется (например, тело функции или просто мертвый код), но ошибка будет выдана, если мы запросим доступ к переменной до её инициализации.

Разница между объявлениями **var**, **let** и **const** заключается в их инициализации.

Экземпляры **var** и **let** могут быть инициализированы без значения, в то время как const выдаст ошибку ReferenceError, если ты попытаешься объявить её без одновременного присвоения ей значения. Так что const myName = 'Alex' будет работать, но const myName; myName = 'Alex'; не будет. С помощью var и let ты можешь попробовать использовать значение var до того, как оно будет присвоено, и оно вернет undefined. Однако, если ты сделаешь то же самое с let - получишь ReferenceError.

![Tux, the Linux mascot](/img/let-const.png)

Также, если ты создашь **var** на верхнем уровне (глобальный уровень), создастся свойство для глобального объекта; в случае с браузером - это объект **window**. Поэтому на создание **var myName = 'Alex'**; можно ссылаться также путем вызова window.myName.

Однако, если ты напишешь **let newName = 'Alex'**; это не будет доступно в глобальном объекте **window** - следовательно, ты не сможешь использовать **window.newName** в качестве ссылки на **'Alex'** ,

К объявлениям, сделанным с помощью var, можно получить доступ за пределами их первоначальной области видимости, тогда как к объявлениям, сделанным с помощью **let** и **const**, нельзя.

![Tux, the Linux mascot](/img/const.png)
