# Table of Contents
### 1.**SCOPE**   
### 2.**HOISTING**
### 3.**Recursion**
### 4.**Closure**
_________________

## Введение в JavaScript scope

![Tux, the Linux mascot](/assets/images/tux.png)

Введение в JavaScript scope (область видимости функции, область видимости блока).

* Область видимости или Scope
* Глобальная область видимости или Global Scope.
*  Область видимости или Scope
* Локальная область видимости или Local Scope.
* Область видимости функции.
* Область видимости блока.
* Лексическая область видимости
* Динамическая область видимости.
_________________

## Поднятие или hoisting в JavaScript

![Tux, the Linux mascot](/assets/images/tux.png)

Что такое "поднятие" и как оно работает в JavaScript.

1. Поднятие (hoisting).
2. Поднятие функций.
3. Поднятие const, let и var.
    - Ключевое слово var
    - Ключевое слово const/let

## Поднятие (hoisting)

Поднятие предполагает, что объявления переменных **var** и функций **function** физически перемещаются в начало кода, но, на самом деле это не так.

По сути, когда Javascript компилирует весь код, все объявления переменных, использующие **var**, поднимаются/hoisted в верхнюю часть их функциональной/локальной области видимости (если объявляется внутри функции) или в глобальную область видимости (если объявляется вне функции) независимо от того, где была сделана фактическая декларация.

Объявления переменных и функций помещаются в память на этапе компиляции, но они остаются именно там, где мы ввели их в свой код.

Итак, под капотом происходит следующее: на этапе создания, движок JavaScript просматривает код и, как только он видит ключевое слово **var** или ключевое слово **function**, он выделяет некоторую память для них.

## Поднятие const, let и var
**var** - это традиционный способ объявления переменных в JavaScript.

ES6 (ECMAScript 6) представил два новых способа объявления переменных: **const** и **let**, и, как правило, они рекомендуются во избежание неожиданных осложнений при подъеме.

### Ключевое слово var

*  **var** имеет область действия функции;
* объявления var поднимаются, но не инициализируются.

![Tux, the Linux mascot](/assets/images/tux.png)

Приведенный выше код, из-за поднятия эквивалентен приведенному коду ниже.

![Tux, the Linux mascot](/assets/images/tux.png)

## Ключевые слова const / let
* **const** и let имеют область видимости блока.

На самом деле объявления **var**, **let**, **const**, **function** и **class** поднимаются; но, мы должны помнить, что концепция поднятия не является буквальным процессом (т. е. сами объявления не перемещаются в начало файла - это просто процесс компилятора JavaScript, который сначала читает их, чтобы освободить для них место в памяти).

Разница между объявлениями **var / function** и объявлениями **let / const / class** заключается в инициализации. Первые инициализируются с неопределенным значением undefined. Однако, вторые, лексически объявленные переменные, остаются не инициализированными. Это означает, что ReferenceError выбрасывается при попытке доступа к ним. Они будут инициализированы только после того, как операторы **let / const / class** будут определены. Всё что до, называется временной мертвой зоной.

Временная мертвая зона - это не синтаксическое местоположение, а время между созданием переменной (области) и инициализацией. Ссылка на переменную в коде над объявлением не является ошибкой, если этот код не выполняется (например, тело функции или просто мертвый код), но ошибка будет выдана, если мы запросим доступ к переменной до её инициализации.

Разница между объявлениями **var**, **let** и **const** заключается в их инициализации.

Экземпляры **var** и **let** могут быть инициализированы без значения, в то время как const выдаст ошибку ReferenceError, если ты попытаешься объявить её без одновременного присвоения ей значения. Так что const myName = 'Alex' будет работать, но const myName; myName = 'Alex'; не будет. С помощью var и let ты можешь попробовать использовать значение var до того, как оно будет присвоено, и оно вернет undefined. Однако, если ты сделаешь то же самое с let - получишь ReferenceError.

![Tux, the Linux mascot](/assets/images/tux.png)

Также, если ты создашь **var** на верхнем уровне (глобальный уровень), создастся свойство для глобального объекта; в случае с браузером - это объект **window**. Поэтому на создание **var myName = 'Alex'**; можно ссылаться также путем вызова window.myName.

Однако, если ты напишешь **let newName = 'Alex'**; это не будет доступно в глобальном объекте **window** - следовательно, ты не сможешь использовать **window.newName** в качестве ссылки на **'Alex'** ,

К объявлениям, сделанным с помощью var, можно получить доступ за пределами их первоначальной области видимости, тогда как к объявлениям, сделанным с помощью **let** и **const**, нельзя.

![Tux, the Linux mascot](/assets/images/tux.png)
_________________

## Введение в замыкание. Closure

![Tux, the Linux mascot](/assets/images/tux.png)

**Что такое замыкание**

* Замыкание
* Инкапсуляция
* Эффективное использование памяти.

### Замыкание

**Замыкание** обеспечивает доступ к переменным в своей **лексической области**; включая переменные родителей, которые были удалены из стека вызовов, путём определения, какие именно переменные понадобятся дочерним функциям, путём сохранения их в памяти.

Другими словами, замыкание даёт нам доступ к области видимости внешней функции из внутренней функции. В JavaScript замыкания создаются каждый раз, когда во время создания функции, внутри неё создаётся ещё одна функция.

### Инкапсуляция

Инкапсуляция позволяет нам скрывать/показывать свойства функций и объектов.

Замыкания обычно используются для обеспечения конфиденциальности данных объектов. Конфиденциальность данных - это важное свойство, которое помогает нам программировать интерфейс, а не реализацию. Дання концепция важна тем, что помогает нам создавать более надежное программное обеспечение.

В JavaScript, замыкания являются основным механизмом, обеспечивающим конфиденциальность данных. Когда мы используем замыкания для конфиденциальности данных, вложенные переменные находятся только в области действия, внутри содержащей (внешней) функции. Мы не можем получить данные из внешней области, кроме как через привилегированные функции. В JavaScript любая функция, определенная в области замыкания, является привилегированной.

**Замыкания** подобны объектам в том смысле, что они представляют собой механизм для хранения состояния:

Например, в приведенном ниже примере, мы не хотим показывать функцию **launch** для её вызова, а также не даём доступ к **timeWithoutDesctruction**:

![Tux, the Linux mascot](/assets/images/tux.png)

Таким образом, мы скрываем данные объекта, которые не должны быть напрямую доступны. Вместо прямого доступа к данным нужно вызывать методы.